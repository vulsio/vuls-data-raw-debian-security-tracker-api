{
	"id": "CVE-2024-26737",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix racing between bpf_timer_cancel_and_free and bpf_timer_cancel  The following race is possible between bpf_timer_cancel_and_free and bpf_timer_cancel. It will lead a UAF on the timer->timer.  bpf_timer_cancel(); \tspin_lock(); \tt = timer->time; \tspin_unlock();  \t\t\t\t\tbpf_timer_cancel_and_free(); \t\t\t\t\t\tspin_lock(); \t\t\t\t\t\tt = timer->timer; \t\t\t\t\t\ttimer->timer = NULL; \t\t\t\t\t\tspin_unlock(); \t\t\t\t\t\thrtimer_cancel(&t->timer); \t\t\t\t\t\tkfree(t);  \t/* UAF on t */ \thrtimer_cancel(&t->timer);  In bpf_timer_cancel_and_free, this patch frees the timer->timer after a rcu grace period. This requires a rcu_head addition to the \"struct bpf_hrtimer\". Another kfree(t) happens in bpf_timer_init, this does not need a kfree_rcu because it is still under the spin_lock and timer->timer has not been visible by others yet.  In bpf_timer_cancel, rcu_read_lock() is added because this helper can be used in a non rcu critical section context (e.g. from a sleepable bpf prog). Other timer->timer usages in helpers.c have been audited, bpf_timer_cancel() is the only place where timer->timer is used outside of the spin_lock.  Another solution considered is to mark a t->flag in bpf_timer_cancel and clear it after hrtimer_cancel() is done.  In bpf_timer_cancel_and_free, it busy waits for the flag to be cleared before kfree(t). This patch goes with a straight forward solution and frees timer->timer after a rcu grace period.",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "6.1.82-1",
			"repository": [
				{
					"name": "bookworm-security",
					"version": "6.1.99-1"
				},
				{
					"name": "bookworm",
					"version": "6.1.94-1"
				}
			]
		}
	]
}
