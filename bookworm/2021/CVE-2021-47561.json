{
	"id": "CVE-2021-47561",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  i2c: virtio: disable timeout handling  If a timeout is hit, it can result is incorrect data on the I2C bus and/or memory corruptions in the guest since the device can still be operating on the buffers it was given while the guest has freed them.  Here is, for example, the start of a slub_debug splat which was triggered on the next transfer after one transfer was forced to timeout by setting a breakpoint in the backend (rust-vmm/vhost-device):   BUG kmalloc-1k (Not tainted): Poison overwritten  First byte 0x1 instead of 0x6b  Allocated in virtio_i2c_xfer+0x65/0x35c age=350 cpu=0 pid=29  \t__kmalloc+0xc2/0x1c9  \tvirtio_i2c_xfer+0x65/0x35c  \t__i2c_transfer+0x429/0x57d  \ti2c_transfer+0x115/0x134  \ti2cdev_ioctl_rdwr+0x16a/0x1de  \ti2cdev_ioctl+0x247/0x2ed  \tvfs_ioctl+0x21/0x30  \tsys_ioctl+0xb18/0xb41  Freed in virtio_i2c_xfer+0x32e/0x35c age=244 cpu=0 pid=29  \tkfree+0x1bd/0x1cc  \tvirtio_i2c_xfer+0x32e/0x35c  \t__i2c_transfer+0x429/0x57d  \ti2c_transfer+0x115/0x134  \ti2cdev_ioctl_rdwr+0x16a/0x1de  \ti2cdev_ioctl+0x247/0x2ed  \tvfs_ioctl+0x21/0x30  \tsys_ioctl+0xb18/0xb41  There is no simple fix for this (the driver would have to always create bounce buffers and hold on to them until the device eventually returns the buffers), so just disable the timeout support for now.",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "5.15.15-1",
			"repository": [
				{
					"name": "bookworm",
					"version": "6.1.123-1"
				},
				{
					"name": "bookworm-security",
					"version": "6.1.128-1"
				}
			]
		}
	]
}
