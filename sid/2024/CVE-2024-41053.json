{
	"id": "CVE-2024-41053",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Fix ufshcd_abort_one racing issue  When ufshcd_abort_one is racing with the completion ISR, the completed tag of the request's mq_hctx pointer will be set to NULL by ISR.  Return success when request is completed by ISR because ufshcd_abort_one does not need to do anything.  The racing flow is:  Thread A ufshcd_err_handler\t\t\t\t\tstep 1 \t... \tufshcd_abort_one \t\tufshcd_try_to_abort_task \t\t\tufshcd_cmd_inflight(true)\tstep 3 \t\tufshcd_mcq_req_to_hwq \t\t\tblk_mq_unique_tag \t\t\t\trq->mq_hctx->queue_num\tstep 5  Thread B ufs_mtk_mcq_intr(cq complete ISR)\t\t\tstep 2 \tscsi_done \t\t... \t\t__blk_mq_free_request \t\t\trq->mq_hctx = NULL;\t\tstep 4  Below is KE back trace.   ufshcd_try_to_abort_task: cmd at tag 41 not pending in the device.   ufshcd_try_to_abort_task: cmd at tag=41 is cleared.   Aborting tag 41 / CDB 0x28 succeeded   Unable to handle kernel NULL pointer dereference at virtual address 0000000000000194   pc : [0xffffffddd7a79bf8] blk_mq_unique_tag+0x8/0x14   lr : [0xffffffddd6155b84] ufshcd_mcq_req_to_hwq+0x1c/0x40 [ufs_mediatek_mod_ise]    do_mem_abort+0x58/0x118    el1_abort+0x3c/0x5c    el1h_64_sync_handler+0x54/0x90    el1h_64_sync+0x68/0x6c    blk_mq_unique_tag+0x8/0x14    ufshcd_err_handler+0xae4/0xfa8 [ufs_mediatek_mod_ise]    process_one_work+0x208/0x4fc    worker_thread+0x228/0x438    kthread+0x104/0x1d4    ret_from_fork+0x10/0x20",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "6.9.10-1",
			"repository": [
				{
					"name": "sid",
					"version": "6.12.8-1"
				}
			]
		}
	]
}
