{
	"id": "CVE-2024-47679",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  vfs: fix race between evice_inodes() and find_inode()&iput()  Hi, all  Recently I noticed a bug[1] in btrfs, after digged it into and I believe it'a race in vfs.  Let's assume there's a inode (ie ino 261) with i_count 1 is called by iput(), and there's a concurrent thread calling generic_shutdown_super().  cpu0:                              cpu1: iput() // i_count is 1   ->spin_lock(inode)   ->dec i_count to 0   ->iput_final()                    generic_shutdown_super()     ->__inode_add_lru()               ->evict_inodes()       // cause some reason[2]           ->if (atomic_read(inode->i_count)) continue;       // return before                  // inode 261 passed the above check       // list_lru_add_obj()             // and then schedule out    ->spin_unlock() // note here: the inode 261 // was still at sb list and hash list, // and I_FREEING|I_WILL_FREE was not been set  btrfs_iget()   // after some function calls   ->find_inode()     // found the above inode 261     ->spin_lock(inode)    // check I_FREEING|I_WILL_FREE    // and passed       ->__iget()     ->spin_unlock(inode)                // schedule back                                         ->spin_lock(inode)                                         // check (I_NEW|I_FREEING|I_WILL_FREE) flags,                                         // passed and set I_FREEING iput()                                  ->spin_unlock(inode)   ->spin_lock(inode)\t\t\t  ->evict()   // dec i_count to 0   ->iput_final()     ->spin_unlock()     ->evict()  Now, we have two threads simultaneously evicting the same inode, which may trigger the BUG(inode->i_state & I_CLEAR) statement both within clear_inode() and iput().  To fix the bug, recheck the inode->i_count after holding i_lock. Because in the most scenarios, the first check is valid, and the overhead of spin_lock() can be reduced.  If there is any misunderstanding, please let me know, thanks.  [1]: https://lore.kernel.org/linux-btrfs/000000000000eabe1d0619c48986@google.com/ [2]: The reason might be 1. SB_ACTIVE was removed or 2. mapping_shrinkable() return false when I reproduced the bug.",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "6.11.2-1",
			"repository": [
				{
					"name": "sid",
					"version": "6.11.4-1"
				}
			]
		}
	]
}
