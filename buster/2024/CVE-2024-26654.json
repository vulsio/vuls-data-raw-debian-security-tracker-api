{
	"id": "CVE-2024-26654",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: sh: aica: reorder cleanup operations to avoid UAF bugs  The dreamcastcard->timer could schedule the spu_dma_work and the spu_dma_work could also arm the dreamcastcard->timer.  When the snd_pcm_substream is closing, the aica_channel will be deallocated. But it could still be dereferenced in the worker thread. The reason is that del_timer() will return directly regardless of whether the timer handler is running or not and the worker could be rescheduled in the timer handler. As a result, the UAF bug will happen. The racy situation is shown below:        (Thread 1)                 |      (Thread 2) snd_aicapcm_pcm_close()          |  ...                             |  run_spu_dma() //worker                                  |    mod_timer()   flush_work()                   |   del_timer()                    |  aica_period_elapsed() //timer   kfree(dreamcastcard->channel)  |    schedule_work()                                  |  run_spu_dma() //worker   ...                            |    dreamcastcard->channel-> //USE  In order to mitigate this bug and other possible corner cases, call mod_timer() conditionally in run_spu_dma(), then implement PCM sync_stop op to cancel both the timer and worker. The sync_stop op will be called from PCM core appropriately when needed.",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "open",
			"nodsa": "sh4 not a release architecture",
			"nodsa_reason": "ignored",
			"urgency": "not yet assigned",
			"repository": [
				{
					"name": "buster",
					"version": "4.19.249-2"
				},
				{
					"name": "buster-security",
					"version": "4.19.316-1"
				}
			]
		},
		{
			"name": "linux-5.10",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "5.10.216-1~deb10u1",
			"repository": [
				{
					"name": "buster-security",
					"version": "5.10.218-1~deb10u1"
				}
			]
		}
	]
}
