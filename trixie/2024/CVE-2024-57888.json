{
	"id": "CVE-2024-57888",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  workqueue: Do not warn when cancelling WQ_MEM_RECLAIM work from !WQ_MEM_RECLAIM worker  After commit 746ae46c1113 (\"drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM\") amdgpu started seeing the following warning:   [ ] workqueue: WQ_MEM_RECLAIM sdma0:drm_sched_run_job_work [gpu_sched] is flushing !WQ_MEM_RECLAIM events:amdgpu_device_delay_enable_gfx_off [amdgpu] ...  [ ] Workqueue: sdma0 drm_sched_run_job_work [gpu_sched] ...  [ ] Call Trace:  [ ]  <TASK> ...  [ ]  ? check_flush_dependency+0xf5/0x110 ...  [ ]  cancel_delayed_work_sync+0x6e/0x80  [ ]  amdgpu_gfx_off_ctrl+0xab/0x140 [amdgpu]  [ ]  amdgpu_ring_alloc+0x40/0x50 [amdgpu]  [ ]  amdgpu_ib_schedule+0xf4/0x810 [amdgpu]  [ ]  ? drm_sched_run_job_work+0x22c/0x430 [gpu_sched]  [ ]  amdgpu_job_run+0xaa/0x1f0 [amdgpu]  [ ]  drm_sched_run_job_work+0x257/0x430 [gpu_sched]  [ ]  process_one_work+0x217/0x720 ...  [ ]  </TASK>  The intent of the verifcation done in check_flush_depedency is to ensure forward progress during memory reclaim, by flagging cases when either a memory reclaim process, or a memory reclaim work item is flushed from a context not marked as memory reclaim safe.  This is correct when flushing, but when called from the cancel(_delayed)_work_sync() paths it is a false positive because work is either already running, or will not be running at all. Therefore cancelling it is safe and we can relax the warning criteria by letting the helper know of the calling context.  References: 746ae46c1113 (\"drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM\")",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "6.12.9-1",
			"repository": [
				{
					"name": "trixie",
					"version": "6.12.9-1"
				}
			]
		}
	]
}
