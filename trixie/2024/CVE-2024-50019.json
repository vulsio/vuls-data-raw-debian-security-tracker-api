{
	"id": "CVE-2024-50019",
	"description": "In the Linux kernel, the following vulnerability has been resolved:  kthread: unpark only parked kthread  Calling into kthread unparking unconditionally is mostly harmless when the kthread is already unparked. The wake up is then simply ignored because the target is not in TASK_PARKED state.  However if the kthread is per CPU, the wake up is preceded by a call to kthread_bind() which expects the task to be inactive and in TASK_PARKED state, which obviously isn't the case if it is unparked.  As a result, calling kthread_stop() on an unparked per-cpu kthread triggers such a warning:  \tWARNING: CPU: 0 PID: 11 at kernel/kthread.c:525 __kthread_bind_mask kernel/kthread.c:525 \t <TASK> \t kthread_stop+0x17a/0x630 kernel/kthread.c:707 \t destroy_workqueue+0x136/0xc40 kernel/workqueue.c:5810 \t wg_destruct+0x1e2/0x2e0 drivers/net/wireguard/device.c:257 \t netdev_run_todo+0xe1a/0x1000 net/core/dev.c:10693 \t default_device_exit_batch+0xa14/0xa90 net/core/dev.c:11769 \t ops_exit_list net/core/net_namespace.c:178 [inline] \t cleanup_net+0x89d/0xcc0 net/core/net_namespace.c:640 \t process_one_work kernel/workqueue.c:3231 [inline] \t process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3312 \t worker_thread+0x86d/0xd70 kernel/workqueue.c:3393 \t kthread+0x2f0/0x390 kernel/kthread.c:389 \t ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 \t ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 \t </TASK>  Fix this with skipping unecessary unparking while stopping a kthread.",
	"scope": "local",
	"packages": [
		{
			"name": "linux",
			"status": "resolved",
			"urgency": "not yet assigned",
			"fixed_version": "6.11.4-1",
			"repository": [
				{
					"name": "trixie",
					"version": "6.11.9-1"
				}
			]
		}
	]
}
